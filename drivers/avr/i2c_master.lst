   1               		.file	"i2c_master.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.i2c_init,"ax",@progbits
  11               	.global	i2c_init
  13               	i2c_init:
  14               	.LFB0:
  15               		.file 1 "keyboards/dc01/left/../../../drivers/avr/i2c_master.c"
   1:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** /* Library made by: g4lvanix
   2:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****  * Github repository: https://github.com/g4lvanix/I2C-master-lib
   3:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****  */
   4:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
   5:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** #include <avr/io.h>
   6:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** #include <util/twi.h>
   7:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
   8:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** #include "i2c_master.h"
   9:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** #include "timer.h"
  10:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  11:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** #define F_SCL 400000UL // SCL frequency
  12:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** #define Prescaler 1
  13:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** #define TWBR_val ((((F_CPU / F_SCL) / Prescaler) - 16 ) / 2)
  14:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  15:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** void i2c_init(void)
  16:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
  16               		.loc 1 16 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  17:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWSR = 0;     /* no prescaler */
  22               		.loc 1 17 0
  23 0000 1092 B900 		sts 185,__zero_reg__
  18:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWBR = (uint8_t)TWBR_val;
  24               		.loc 1 18 0
  25 0004 8CE0      		ldi r24,lo8(12)
  26 0006 8093 B800 		sts 184,r24
  27 000a 0895      		ret
  28               		.cfi_endproc
  29               	.LFE0:
  31               		.section	.text.i2c_start,"ax",@progbits
  32               	.global	i2c_start
  34               	i2c_start:
  35               	.LFB1:
  19:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
  20:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  21:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** i2c_status_t i2c_start(uint8_t address, uint16_t timeout)
  22:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
  36               		.loc 1 22 0
  37               		.cfi_startproc
  38               	.LVL0:
  39 0000 FF92      		push r15
  40               	.LCFI0:
  41               		.cfi_def_cfa_offset 3
  42               		.cfi_offset 15, -2
  43 0002 0F93      		push r16
  44               	.LCFI1:
  45               		.cfi_def_cfa_offset 4
  46               		.cfi_offset 16, -3
  47 0004 1F93      		push r17
  48               	.LCFI2:
  49               		.cfi_def_cfa_offset 5
  50               		.cfi_offset 17, -4
  51 0006 CF93      		push r28
  52               	.LCFI3:
  53               		.cfi_def_cfa_offset 6
  54               		.cfi_offset 28, -5
  55 0008 DF93      		push r29
  56               	.LCFI4:
  57               		.cfi_def_cfa_offset 7
  58               		.cfi_offset 29, -6
  59               	/* prologue: function */
  60               	/* frame size = 0 */
  61               	/* stack size = 5 */
  62               	.L__stack_usage = 5
  63 000a F82E      		mov r15,r24
  64 000c EB01      		movw r28,r22
  23:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // reset TWI control register
  24:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWCR = 0;
  65               		.loc 1 24 0
  66 000e 1092 BC00 		sts 188,__zero_reg__
  25:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // transmit START condition
  26:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
  67               		.loc 1 26 0
  68 0012 84EA      		ldi r24,lo8(-92)
  69               	.LVL1:
  70 0014 8093 BC00 		sts 188,r24
  27:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  28:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   uint16_t timeout_timer = timer_read();
  71               		.loc 1 28 0
  72 0018 0E94 0000 		call timer_read
  73               	.LVL2:
  74 001c 8C01      		movw r16,r24
  75               	.LVL3:
  76               	.L5:
  29:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   while( !(TWCR & (1<<TWINT)) ) {
  77               		.loc 1 29 0 discriminator 1
  78 001e 8091 BC00 		lds r24,188
  79 0022 87FD      		sbrc r24,7
  80 0024 00C0      		rjmp .L24
  30:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
  81               		.loc 1 30 0
  82 0026 CF3F      		cpi r28,-1
  83 0028 8FEF      		ldi r24,-1
  84 002a D807      		cpc r29,r24
  85 002c 01F0      		breq .L5
  86               		.loc 1 30 0 is_stmt 0 discriminator 1
  87 002e 0E94 0000 		call timer_read
  88               	.LVL4:
  89 0032 801B      		sub r24,r16
  90 0034 910B      		sbc r25,r17
  91 0036 8C17      		cp r24,r28
  92 0038 9D07      		cpc r25,r29
  93 003a 00F0      		brlo .L5
  94               	.L13:
  31:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       return I2C_STATUS_TIMEOUT;
  95               		.loc 1 31 0 is_stmt 1
  96 003c 8EEF      		ldi r24,lo8(-2)
  97 003e 9FEF      		ldi r25,lo8(-1)
  98 0040 00C0      		rjmp .L7
  99               	.L24:
  32:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     }
  33:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
  34:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  35:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // check if the start condition was successfully transmitted
  36:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if(((TW_STATUS & 0xF8) != TW_START) && ((TW_STATUS & 0xF8) != TW_REP_START)){ return I2C_STATUS_E
 100               		.loc 1 36 0
 101 0042 9091 B900 		lds r25,185
 102 0046 987F      		andi r25,lo8(-8)
 103 0048 9830      		cpi r25,lo8(8)
 104 004a 01F0      		breq .L9
 105               		.loc 1 36 0 is_stmt 0 discriminator 1
 106 004c 9091 B900 		lds r25,185
 107 0050 987F      		andi r25,lo8(-8)
 108 0052 9031      		cpi r25,lo8(16)
 109 0054 01F0      		breq .L9
 110               	.L15:
 111               		.loc 1 36 0
 112 0056 8FEF      		ldi r24,lo8(-1)
 113 0058 9FEF      		ldi r25,lo8(-1)
 114 005a 00C0      		rjmp .L7
 115               	.L9:
  37:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  38:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // load slave address into data register
  39:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWDR = address;
 116               		.loc 1 39 0 is_stmt 1
 117 005c F092 BB00 		sts 187,r15
  40:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // start transmission of address
  41:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWCR = (1<<TWINT) | (1<<TWEN);
 118               		.loc 1 41 0
 119 0060 84E8      		ldi r24,lo8(-124)
 120 0062 8093 BC00 		sts 188,r24
  42:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  43:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   timeout_timer = timer_read();
 121               		.loc 1 43 0
 122 0066 0E94 0000 		call timer_read
 123               	.LVL5:
 124 006a 8C01      		movw r16,r24
 125               	.LVL6:
 126               	.L12:
  44:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   while( !(TWCR & (1<<TWINT)) ) {
 127               		.loc 1 44 0 discriminator 1
 128 006c 8091 BC00 		lds r24,188
 129 0070 87FD      		sbrc r24,7
 130 0072 00C0      		rjmp .L25
  45:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
 131               		.loc 1 45 0
 132 0074 CF3F      		cpi r28,-1
 133 0076 8FEF      		ldi r24,-1
 134 0078 D807      		cpc r29,r24
 135 007a 01F0      		breq .L12
 136               		.loc 1 45 0 is_stmt 0 discriminator 1
 137 007c 0E94 0000 		call timer_read
 138               	.LVL7:
 139 0080 801B      		sub r24,r16
 140 0082 910B      		sbc r25,r17
 141 0084 8C17      		cp r24,r28
 142 0086 9D07      		cpc r25,r29
 143 0088 00F0      		brlo .L12
 144 008a 00C0      		rjmp .L13
 145               	.L25:
  46:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       return I2C_STATUS_TIMEOUT;
  47:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     }
  48:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
  49:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  50:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // check if the device has acknowledged the READ / WRITE mode
  51:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   uint8_t twst = TW_STATUS & 0xF8;
 146               		.loc 1 51 0 is_stmt 1
 147 008c 8091 B900 		lds r24,185
 148 0090 887F      		andi r24,lo8(-8)
 149               	.LVL8:
  52:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return I2C_STATUS_ERROR;
 150               		.loc 1 52 0
 151 0092 8831      		cpi r24,lo8(24)
 152 0094 01F0      		breq .L16
 153               		.loc 1 52 0 is_stmt 0 discriminator 1
 154 0096 8034      		cpi r24,lo8(64)
 155 0098 01F4      		brne .L15
 156               	.L16:
  53:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  54:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   return I2C_STATUS_SUCCESS;
 157               		.loc 1 54 0 is_stmt 1
 158 009a 80E0      		ldi r24,0
 159 009c 90E0      		ldi r25,0
 160               	.LVL9:
 161               	.L7:
 162               	/* epilogue start */
  55:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 163               		.loc 1 55 0
 164 009e DF91      		pop r29
 165 00a0 CF91      		pop r28
 166               	.LVL10:
 167 00a2 1F91      		pop r17
 168 00a4 0F91      		pop r16
 169               	.LVL11:
 170 00a6 FF90      		pop r15
 171               	.LVL12:
 172 00a8 0895      		ret
 173               		.cfi_endproc
 174               	.LFE1:
 176               		.section	.text.i2c_write,"ax",@progbits
 177               	.global	i2c_write
 179               	i2c_write:
 180               	.LFB2:
  56:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  57:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** i2c_status_t i2c_write(uint8_t data, uint16_t timeout)
  58:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 181               		.loc 1 58 0
 182               		.cfi_startproc
 183               	.LVL13:
 184 0000 0F93      		push r16
 185               	.LCFI5:
 186               		.cfi_def_cfa_offset 3
 187               		.cfi_offset 16, -2
 188 0002 1F93      		push r17
 189               	.LCFI6:
 190               		.cfi_def_cfa_offset 4
 191               		.cfi_offset 17, -3
 192 0004 CF93      		push r28
 193               	.LCFI7:
 194               		.cfi_def_cfa_offset 5
 195               		.cfi_offset 28, -4
 196 0006 DF93      		push r29
 197               	.LCFI8:
 198               		.cfi_def_cfa_offset 6
 199               		.cfi_offset 29, -5
 200               	/* prologue: function */
 201               	/* frame size = 0 */
 202               	/* stack size = 4 */
 203               	.L__stack_usage = 4
 204 0008 EB01      		movw r28,r22
  59:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // load data into data register
  60:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWDR = data;
 205               		.loc 1 60 0
 206 000a 8093 BB00 		sts 187,r24
  61:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // start transmission of data
  62:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWCR = (1<<TWINT) | (1<<TWEN);
 207               		.loc 1 62 0
 208 000e 84E8      		ldi r24,lo8(-124)
 209               	.LVL14:
 210 0010 8093 BC00 		sts 188,r24
 211               	.LVL15:
  63:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  64:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   uint16_t timeout_timer = timer_read();
 212               		.loc 1 64 0
 213 0014 0E94 0000 		call timer_read
 214               	.LVL16:
 215 0018 8C01      		movw r16,r24
 216               	.LVL17:
 217               	.L29:
  65:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   while( !(TWCR & (1<<TWINT)) ) {
 218               		.loc 1 65 0 discriminator 1
 219 001a 8091 BC00 		lds r24,188
 220 001e 87FD      		sbrc r24,7
 221 0020 00C0      		rjmp .L34
  66:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
 222               		.loc 1 66 0
 223 0022 CF3F      		cpi r28,-1
 224 0024 8FEF      		ldi r24,-1
 225 0026 D807      		cpc r29,r24
 226 0028 01F0      		breq .L29
 227               		.loc 1 66 0 is_stmt 0 discriminator 1
 228 002a 0E94 0000 		call timer_read
 229               	.LVL18:
 230 002e 801B      		sub r24,r16
 231 0030 910B      		sbc r25,r17
 232 0032 8C17      		cp r24,r28
 233 0034 9D07      		cpc r25,r29
 234 0036 00F0      		brlo .L29
  67:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       return I2C_STATUS_TIMEOUT;
 235               		.loc 1 67 0 is_stmt 1
 236 0038 8EEF      		ldi r24,lo8(-2)
 237 003a 9FEF      		ldi r25,lo8(-1)
 238 003c 00C0      		rjmp .L30
 239               	.L34:
  68:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     }
  69:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
  70:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  71:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if( (TW_STATUS & 0xF8) != TW_MT_DATA_ACK ){ return I2C_STATUS_ERROR; }
 240               		.loc 1 71 0
 241 003e 2091 B900 		lds r18,185
 242 0042 287F      		andi r18,lo8(-8)
 243 0044 81E0      		ldi r24,lo8(1)
 244 0046 90E0      		ldi r25,0
 245 0048 2832      		cpi r18,lo8(40)
 246 004a 01F4      		brne .L32
 247 004c 80E0      		ldi r24,0
 248 004e 90E0      		ldi r25,0
 249               	.L32:
 250 0050 9195      		neg r25
 251 0052 8195      		neg r24
 252 0054 9109      		sbc r25,__zero_reg__
 253               	.L30:
 254               	/* epilogue start */
  72:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  73:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   return I2C_STATUS_SUCCESS;
  74:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 255               		.loc 1 74 0
 256 0056 DF91      		pop r29
 257 0058 CF91      		pop r28
 258               	.LVL19:
 259 005a 1F91      		pop r17
 260 005c 0F91      		pop r16
 261               	.LVL20:
 262 005e 0895      		ret
 263               		.cfi_endproc
 264               	.LFE2:
 266               		.section	.text.i2c_read_ack,"ax",@progbits
 267               	.global	i2c_read_ack
 269               	i2c_read_ack:
 270               	.LFB3:
  75:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  76:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** int16_t i2c_read_ack(uint16_t timeout)
  77:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 271               		.loc 1 77 0
 272               		.cfi_startproc
 273               	.LVL21:
 274 0000 0F93      		push r16
 275               	.LCFI9:
 276               		.cfi_def_cfa_offset 3
 277               		.cfi_offset 16, -2
 278 0002 1F93      		push r17
 279               	.LCFI10:
 280               		.cfi_def_cfa_offset 4
 281               		.cfi_offset 17, -3
 282 0004 CF93      		push r28
 283               	.LCFI11:
 284               		.cfi_def_cfa_offset 5
 285               		.cfi_offset 28, -4
 286 0006 DF93      		push r29
 287               	.LCFI12:
 288               		.cfi_def_cfa_offset 6
 289               		.cfi_offset 29, -5
 290               	/* prologue: function */
 291               	/* frame size = 0 */
 292               	/* stack size = 4 */
 293               	.L__stack_usage = 4
 294 0008 EC01      		movw r28,r24
  78:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  79:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // start TWI module and acknowledge data after reception
  80:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
 295               		.loc 1 80 0
 296 000a 84EC      		ldi r24,lo8(-60)
 297               	.LVL22:
 298 000c 8093 BC00 		sts 188,r24
  81:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  82:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   uint16_t timeout_timer = timer_read();
 299               		.loc 1 82 0
 300 0010 0E94 0000 		call timer_read
 301               	.LVL23:
 302 0014 8C01      		movw r16,r24
 303               	.LVL24:
 304               	.L38:
  83:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   while( !(TWCR & (1<<TWINT)) ) {
 305               		.loc 1 83 0 discriminator 1
 306 0016 8091 BC00 		lds r24,188
 307 001a 87FD      		sbrc r24,7
 308 001c 00C0      		rjmp .L42
  84:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
 309               		.loc 1 84 0
 310 001e CF3F      		cpi r28,-1
 311 0020 8FEF      		ldi r24,-1
 312 0022 D807      		cpc r29,r24
 313 0024 01F0      		breq .L38
 314               		.loc 1 84 0 is_stmt 0 discriminator 1
 315 0026 0E94 0000 		call timer_read
 316               	.LVL25:
 317 002a 801B      		sub r24,r16
 318 002c 910B      		sbc r25,r17
 319 002e 8C17      		cp r24,r28
 320 0030 9D07      		cpc r25,r29
 321 0032 00F0      		brlo .L38
  85:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       return I2C_STATUS_TIMEOUT;
 322               		.loc 1 85 0 is_stmt 1
 323 0034 8EEF      		ldi r24,lo8(-2)
 324 0036 9FEF      		ldi r25,lo8(-1)
 325 0038 00C0      		rjmp .L39
 326               	.L42:
  86:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     }
  87:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
  88:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  89:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // return received data from TWDR
  90:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   return TWDR;
 327               		.loc 1 90 0
 328 003a 8091 BB00 		lds r24,187
 329 003e 90E0      		ldi r25,0
 330               	.L39:
 331               	/* epilogue start */
  91:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 332               		.loc 1 91 0
 333 0040 DF91      		pop r29
 334 0042 CF91      		pop r28
 335               	.LVL26:
 336 0044 1F91      		pop r17
 337 0046 0F91      		pop r16
 338               	.LVL27:
 339 0048 0895      		ret
 340               		.cfi_endproc
 341               	.LFE3:
 343               		.section	.text.i2c_read_nack,"ax",@progbits
 344               	.global	i2c_read_nack
 346               	i2c_read_nack:
 347               	.LFB4:
  92:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  93:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** int16_t i2c_read_nack(uint16_t timeout)
  94:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 348               		.loc 1 94 0
 349               		.cfi_startproc
 350               	.LVL28:
 351 0000 0F93      		push r16
 352               	.LCFI13:
 353               		.cfi_def_cfa_offset 3
 354               		.cfi_offset 16, -2
 355 0002 1F93      		push r17
 356               	.LCFI14:
 357               		.cfi_def_cfa_offset 4
 358               		.cfi_offset 17, -3
 359 0004 CF93      		push r28
 360               	.LCFI15:
 361               		.cfi_def_cfa_offset 5
 362               		.cfi_offset 28, -4
 363 0006 DF93      		push r29
 364               	.LCFI16:
 365               		.cfi_def_cfa_offset 6
 366               		.cfi_offset 29, -5
 367               	/* prologue: function */
 368               	/* frame size = 0 */
 369               	/* stack size = 4 */
 370               	.L__stack_usage = 4
 371 0008 EC01      		movw r28,r24
  95:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  96:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // start receiving without acknowledging reception
  97:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWCR = (1<<TWINT) | (1<<TWEN);
 372               		.loc 1 97 0
 373 000a 84E8      		ldi r24,lo8(-124)
 374               	.LVL29:
 375 000c 8093 BC00 		sts 188,r24
  98:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
  99:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   uint16_t timeout_timer = timer_read();
 376               		.loc 1 99 0
 377 0010 0E94 0000 		call timer_read
 378               	.LVL30:
 379 0014 8C01      		movw r16,r24
 380               	.LVL31:
 381               	.L46:
 100:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   while( !(TWCR & (1<<TWINT)) ) {
 382               		.loc 1 100 0 discriminator 1
 383 0016 8091 BC00 		lds r24,188
 384 001a 87FD      		sbrc r24,7
 385 001c 00C0      		rjmp .L50
 101:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
 386               		.loc 1 101 0
 387 001e CF3F      		cpi r28,-1
 388 0020 8FEF      		ldi r24,-1
 389 0022 D807      		cpc r29,r24
 390 0024 01F0      		breq .L46
 391               		.loc 1 101 0 is_stmt 0 discriminator 1
 392 0026 0E94 0000 		call timer_read
 393               	.LVL32:
 394 002a 801B      		sub r24,r16
 395 002c 910B      		sbc r25,r17
 396 002e 8C17      		cp r24,r28
 397 0030 9D07      		cpc r25,r29
 398 0032 00F0      		brlo .L46
 102:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       return I2C_STATUS_TIMEOUT;
 399               		.loc 1 102 0 is_stmt 1
 400 0034 8EEF      		ldi r24,lo8(-2)
 401 0036 9FEF      		ldi r25,lo8(-1)
 402 0038 00C0      		rjmp .L47
 403               	.L50:
 103:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     }
 104:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
 105:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 106:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // return received data from TWDR
 107:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   return TWDR;
 404               		.loc 1 107 0
 405 003a 8091 BB00 		lds r24,187
 406 003e 90E0      		ldi r25,0
 407               	.L47:
 408               	/* epilogue start */
 108:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 409               		.loc 1 108 0
 410 0040 DF91      		pop r29
 411 0042 CF91      		pop r28
 412               	.LVL33:
 413 0044 1F91      		pop r17
 414 0046 0F91      		pop r16
 415               	.LVL34:
 416 0048 0895      		ret
 417               		.cfi_endproc
 418               	.LFE4:
 420               		.section	.text.i2c_stop,"ax",@progbits
 421               	.global	i2c_stop
 423               	i2c_stop:
 424               	.LFB9:
 109:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 110:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** i2c_status_t i2c_transmit(uint8_t address, uint8_t* data, uint16_t length, uint16_t timeout)
 111:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 112:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   i2c_status_t status = i2c_start(address | I2C_WRITE, timeout);
 113:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 114:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 115:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   for (uint16_t i = 0; i < length; i++) {
 116:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     status = i2c_write(data[i], timeout);
 117:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if (status) return status;
 118:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
 119:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 120:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 121:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 122:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 123:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   return I2C_STATUS_SUCCESS;
 124:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 125:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 126:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** i2c_status_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length, uint16_t timeout)
 127:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 128:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   i2c_status_t status = i2c_start(address | I2C_READ, timeout);
 129:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 130:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 131:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   for (uint16_t i = 0; i < (length-1); i++) {
 132:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     status = i2c_read_ack(timeout);
 133:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if (status >= 0) {
 134:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       data[i] = status;
 135:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     } else {
 136:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       return status;
 137:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     }
 138:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
 139:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 140:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_read_nack(timeout);
 141:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status >= 0 ) {
 142:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     data[(length-1)] = status;
 143:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   } else {
 144:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     return status;
 145:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
 146:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 147:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 148:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 149:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 150:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   return I2C_STATUS_SUCCESS;
 151:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 152:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 153:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** i2c_status_t i2c_writeReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length, uint16_
 154:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 155:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   i2c_status_t status = i2c_start(devaddr | 0x00, timeout);
 156:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 157:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 158:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_write(regaddr, timeout);
 159:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 160:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 161:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   for (uint16_t i = 0; i < length; i++) {
 162:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     status = i2c_write(data[i], timeout);
 163:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if (status) return status;
 164:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
 165:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 166:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 167:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 168:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 169:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   return I2C_STATUS_SUCCESS;
 170:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 171:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 172:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** i2c_status_t i2c_readReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length, uint16_t
 173:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 174:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   i2c_status_t status = i2c_start(devaddr, timeout);
 175:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 176:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 177:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_write(regaddr, timeout);
 178:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 179:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 180:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_start(devaddr | 0x01, timeout);
 181:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 182:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 183:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   for (uint16_t i = 0; i < (length-1); i++) {
 184:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     status = i2c_read_ack(timeout);
 185:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if (status >= 0) {
 186:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       data[i] = status;
 187:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     } else {
 188:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       return status;
 189:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     }
 190:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
 191:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 192:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_read_nack(timeout);
 193:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status >= 0 ) {
 194:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     data[(length-1)] = status;
 195:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   } else {
 196:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     return status;
 197:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
 198:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 199:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 200:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 201:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 202:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   return I2C_STATUS_SUCCESS;
 203:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 204:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 205:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** i2c_status_t i2c_stop(uint16_t timeout)
 206:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 425               		.loc 1 206 0
 426               		.cfi_startproc
 427               	.LVL35:
 428 0000 0F93      		push r16
 429               	.LCFI17:
 430               		.cfi_def_cfa_offset 3
 431               		.cfi_offset 16, -2
 432 0002 1F93      		push r17
 433               	.LCFI18:
 434               		.cfi_def_cfa_offset 4
 435               		.cfi_offset 17, -3
 436 0004 CF93      		push r28
 437               	.LCFI19:
 438               		.cfi_def_cfa_offset 5
 439               		.cfi_offset 28, -4
 440 0006 DF93      		push r29
 441               	.LCFI20:
 442               		.cfi_def_cfa_offset 6
 443               		.cfi_offset 29, -5
 444               	/* prologue: function */
 445               	/* frame size = 0 */
 446               	/* stack size = 4 */
 447               	.L__stack_usage = 4
 448 0008 EC01      		movw r28,r24
 207:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   // transmit STOP condition
 208:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 449               		.loc 1 208 0
 450 000a 84E9      		ldi r24,lo8(-108)
 451               	.LVL36:
 452 000c 8093 BC00 		sts 188,r24
 209:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 210:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   uint16_t timeout_timer = timer_read();
 453               		.loc 1 210 0
 454 0010 0E94 0000 		call timer_read
 455               	.LVL37:
 456 0014 8C01      		movw r16,r24
 457               	.LVL38:
 458               	.L54:
 211:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   while(TWCR & (1<<TWSTO)) {
 459               		.loc 1 211 0 discriminator 1
 460 0016 8091 BC00 		lds r24,188
 461 001a 84FF      		sbrs r24,4
 462 001c 00C0      		rjmp .L58
 212:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if ((timeout != I2C_TIMEOUT_INFINITE) && ((timer_read() - timeout_timer) >= timeout)) {
 463               		.loc 1 212 0
 464 001e CF3F      		cpi r28,-1
 465 0020 8FEF      		ldi r24,-1
 466 0022 D807      		cpc r29,r24
 467 0024 01F0      		breq .L54
 468               		.loc 1 212 0 is_stmt 0 discriminator 1
 469 0026 0E94 0000 		call timer_read
 470               	.LVL39:
 471 002a 801B      		sub r24,r16
 472 002c 910B      		sbc r25,r17
 473 002e 8C17      		cp r24,r28
 474 0030 9D07      		cpc r25,r29
 475 0032 00F0      		brlo .L54
 213:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       return I2C_STATUS_TIMEOUT;
 476               		.loc 1 213 0 is_stmt 1
 477 0034 8EEF      		ldi r24,lo8(-2)
 478 0036 9FEF      		ldi r25,lo8(-1)
 479 0038 00C0      		rjmp .L55
 480               	.L58:
 214:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     }
 215:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   }
 216:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** 
 217:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   return I2C_STATUS_SUCCESS;
 481               		.loc 1 217 0
 482 003a 80E0      		ldi r24,0
 483 003c 90E0      		ldi r25,0
 484               	.L55:
 485               	/* epilogue start */
 218:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }...
 486               		.loc 1 218 0
 487 003e DF91      		pop r29
 488 0040 CF91      		pop r28
 489               	.LVL40:
 490 0042 1F91      		pop r17
 491 0044 0F91      		pop r16
 492               	.LVL41:
 493 0046 0895      		ret
 494               		.cfi_endproc
 495               	.LFE9:
 497               		.section	.text.i2c_transmit,"ax",@progbits
 498               	.global	i2c_transmit
 500               	i2c_transmit:
 501               	.LFB5:
 111:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 502               		.loc 1 111 0
 503               		.cfi_startproc
 504               	.LVL42:
 505 0000 CF92      		push r12
 506               	.LCFI21:
 507               		.cfi_def_cfa_offset 3
 508               		.cfi_offset 12, -2
 509 0002 DF92      		push r13
 510               	.LCFI22:
 511               		.cfi_def_cfa_offset 4
 512               		.cfi_offset 13, -3
 513 0004 EF92      		push r14
 514               	.LCFI23:
 515               		.cfi_def_cfa_offset 5
 516               		.cfi_offset 14, -4
 517 0006 FF92      		push r15
 518               	.LCFI24:
 519               		.cfi_def_cfa_offset 6
 520               		.cfi_offset 15, -5
 521 0008 0F93      		push r16
 522               	.LCFI25:
 523               		.cfi_def_cfa_offset 7
 524               		.cfi_offset 16, -6
 525 000a 1F93      		push r17
 526               	.LCFI26:
 527               		.cfi_def_cfa_offset 8
 528               		.cfi_offset 17, -7
 529 000c CF93      		push r28
 530               	.LCFI27:
 531               		.cfi_def_cfa_offset 9
 532               		.cfi_offset 28, -8
 533 000e DF93      		push r29
 534               	.LCFI28:
 535               		.cfi_def_cfa_offset 10
 536               		.cfi_offset 29, -9
 537               	/* prologue: function */
 538               	/* frame size = 0 */
 539               	/* stack size = 8 */
 540               	.L__stack_usage = 8
 541 0010 6B01      		movw r12,r22
 542 0012 7A01      		movw r14,r20
 543 0014 8901      		movw r16,r18
 112:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   i2c_status_t status = i2c_start(address | I2C_WRITE, timeout);
 544               		.loc 1 112 0
 545 0016 B901      		movw r22,r18
 546               	.LVL43:
 547 0018 0E94 0000 		call i2c_start
 548               	.LVL44:
 113:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 549               		.loc 1 113 0
 550 001c 0097      		sbiw r24,0
 551 001e 01F4      		brne .L60
 552 0020 E601      		movw r28,r12
 553 0022 EC0C      		add r14,r12
 554 0024 FD1C      		adc r15,r13
 555               	.LVL45:
 556               	.L61:
 557               	.LBB2:
 115:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   for (uint16_t i = 0; i < length; i++) {
 558               		.loc 1 115 0 discriminator 1
 559 0026 CE15      		cp r28,r14
 560 0028 DF05      		cpc r29,r15
 561 002a 01F0      		breq .L65
 116:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     status = i2c_write(data[i], timeout);
 562               		.loc 1 116 0
 563 002c B801      		movw r22,r16
 564 002e 8991      		ld r24,Y+
 565               	.LVL46:
 566 0030 0E94 0000 		call i2c_write
 567               	.LVL47:
 117:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if (status) return status;
 568               		.loc 1 117 0
 569 0034 0097      		sbiw r24,0
 570 0036 01F0      		breq .L61
 571 0038 00C0      		rjmp .L60
 572               	.LVL48:
 573               	.L65:
 574               	.LBE2:
 120:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 575               		.loc 1 120 0
 576 003a C801      		movw r24,r16
 577               	.LVL49:
 578               	/* epilogue start */
 124:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 579               		.loc 1 124 0
 580 003c DF91      		pop r29
 581 003e CF91      		pop r28
 582               	.LVL50:
 583 0040 1F91      		pop r17
 584 0042 0F91      		pop r16
 585               	.LVL51:
 586 0044 FF90      		pop r15
 587 0046 EF90      		pop r14
 588 0048 DF90      		pop r13
 589 004a CF90      		pop r12
 590               	.LVL52:
 120:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 591               		.loc 1 120 0
 592 004c 0C94 0000 		jmp i2c_stop
 593               	.LVL53:
 594               	.L60:
 595               	/* epilogue start */
 124:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 596               		.loc 1 124 0
 597 0050 DF91      		pop r29
 598 0052 CF91      		pop r28
 599 0054 1F91      		pop r17
 600 0056 0F91      		pop r16
 601               	.LVL54:
 602 0058 FF90      		pop r15
 603 005a EF90      		pop r14
 604 005c DF90      		pop r13
 605 005e CF90      		pop r12
 606               	.LVL55:
 607 0060 0895      		ret
 608               		.cfi_endproc
 609               	.LFE5:
 611               		.section	.text.i2c_receive,"ax",@progbits
 612               	.global	i2c_receive
 614               	i2c_receive:
 615               	.LFB6:
 127:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 616               		.loc 1 127 0
 617               		.cfi_startproc
 618               	.LVL56:
 619 0000 CF92      		push r12
 620               	.LCFI29:
 621               		.cfi_def_cfa_offset 3
 622               		.cfi_offset 12, -2
 623 0002 DF92      		push r13
 624               	.LCFI30:
 625               		.cfi_def_cfa_offset 4
 626               		.cfi_offset 13, -3
 627 0004 EF92      		push r14
 628               	.LCFI31:
 629               		.cfi_def_cfa_offset 5
 630               		.cfi_offset 14, -4
 631 0006 FF92      		push r15
 632               	.LCFI32:
 633               		.cfi_def_cfa_offset 6
 634               		.cfi_offset 15, -5
 635 0008 0F93      		push r16
 636               	.LCFI33:
 637               		.cfi_def_cfa_offset 7
 638               		.cfi_offset 16, -6
 639 000a 1F93      		push r17
 640               	.LCFI34:
 641               		.cfi_def_cfa_offset 8
 642               		.cfi_offset 17, -7
 643 000c CF93      		push r28
 644               	.LCFI35:
 645               		.cfi_def_cfa_offset 9
 646               		.cfi_offset 28, -8
 647 000e DF93      		push r29
 648               	.LCFI36:
 649               		.cfi_def_cfa_offset 10
 650               		.cfi_offset 29, -9
 651               	/* prologue: function */
 652               	/* frame size = 0 */
 653               	/* stack size = 8 */
 654               	.L__stack_usage = 8
 655 0010 8B01      		movw r16,r22
 656 0012 6A01      		movw r12,r20
 657 0014 E901      		movw r28,r18
 128:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   i2c_status_t status = i2c_start(address | I2C_READ, timeout);
 658               		.loc 1 128 0
 659 0016 B901      		movw r22,r18
 660               	.LVL57:
 661 0018 8160      		ori r24,lo8(1)
 662               	.LVL58:
 663 001a 0E94 0000 		call i2c_start
 664               	.LVL59:
 129:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 665               		.loc 1 129 0
 666 001e 0097      		sbiw r24,0
 667 0020 01F4      		brne .L67
 668 0022 7801      		movw r14,r16
 669               	.LBB3:
 131:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   for (uint16_t i = 0; i < (length-1); i++) {
 670               		.loc 1 131 0
 671 0024 81E0      		ldi r24,1
 672 0026 C81A      		sub r12,r24
 673 0028 D108      		sbc r13,__zero_reg__
 674               	.LVL60:
 675               	.L68:
 676 002a C701      		movw r24,r14
 677 002c 801B      		sub r24,r16
 678 002e 910B      		sbc r25,r17
 679               	.LVL61:
 131:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   for (uint16_t i = 0; i < (length-1); i++) {
 680               		.loc 1 131 0 is_stmt 0 discriminator 1
 681 0030 8C15      		cp r24,r12
 682 0032 9D05      		cpc r25,r13
 683 0034 00F4      		brsh .L73
 132:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     status = i2c_read_ack(timeout);
 684               		.loc 1 132 0 is_stmt 1
 685 0036 CE01      		movw r24,r28
 686               	.LVL62:
 687 0038 0E94 0000 		call i2c_read_ack
 688               	.LVL63:
 133:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if (status >= 0) {
 689               		.loc 1 133 0
 690 003c 97FD      		sbrc r25,7
 691 003e 00C0      		rjmp .L67
 134:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       data[i] = status;
 692               		.loc 1 134 0
 693 0040 F701      		movw r30,r14
 694 0042 8193      		st Z+,r24
 695 0044 7F01      		movw r14,r30
 696               	.LVL64:
 697 0046 00C0      		rjmp .L68
 698               	.LVL65:
 699               	.L73:
 700               	.LBE3:
 140:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_read_nack(timeout);
 701               		.loc 1 140 0
 702 0048 CE01      		movw r24,r28
 703               	.LVL66:
 704 004a 0E94 0000 		call i2c_read_nack
 705               	.LVL67:
 141:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status >= 0 ) {
 706               		.loc 1 141 0
 707 004e 97FD      		sbrc r25,7
 708 0050 00C0      		rjmp .L67
 142:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     data[(length-1)] = status;
 709               		.loc 1 142 0
 710 0052 F801      		movw r30,r16
 711 0054 EC0D      		add r30,r12
 712 0056 FD1D      		adc r31,r13
 713 0058 8083      		st Z,r24
 147:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 714               		.loc 1 147 0
 715 005a CE01      		movw r24,r28
 716               	.LVL68:
 717               	/* epilogue start */
 151:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 718               		.loc 1 151 0
 719 005c DF91      		pop r29
 720 005e CF91      		pop r28
 721               	.LVL69:
 722 0060 1F91      		pop r17
 723 0062 0F91      		pop r16
 724               	.LVL70:
 725 0064 FF90      		pop r15
 726 0066 EF90      		pop r14
 727               	.LVL71:
 728 0068 DF90      		pop r13
 729 006a CF90      		pop r12
 730               	.LVL72:
 147:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 731               		.loc 1 147 0
 732 006c 0C94 0000 		jmp i2c_stop
 733               	.LVL73:
 734               	.L67:
 735               	/* epilogue start */
 151:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 736               		.loc 1 151 0
 737 0070 DF91      		pop r29
 738 0072 CF91      		pop r28
 739               	.LVL74:
 740 0074 1F91      		pop r17
 741 0076 0F91      		pop r16
 742               	.LVL75:
 743 0078 FF90      		pop r15
 744 007a EF90      		pop r14
 745 007c DF90      		pop r13
 746 007e CF90      		pop r12
 747 0080 0895      		ret
 748               		.cfi_endproc
 749               	.LFE6:
 751               		.section	.text.i2c_writeReg,"ax",@progbits
 752               	.global	i2c_writeReg
 754               	i2c_writeReg:
 755               	.LFB7:
 154:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 756               		.loc 1 154 0
 757               		.cfi_startproc
 758               	.LVL76:
 759 0000 CF92      		push r12
 760               	.LCFI37:
 761               		.cfi_def_cfa_offset 3
 762               		.cfi_offset 12, -2
 763 0002 DF92      		push r13
 764               	.LCFI38:
 765               		.cfi_def_cfa_offset 4
 766               		.cfi_offset 13, -3
 767 0004 EF92      		push r14
 768               	.LCFI39:
 769               		.cfi_def_cfa_offset 5
 770               		.cfi_offset 14, -4
 771 0006 FF92      		push r15
 772               	.LCFI40:
 773               		.cfi_def_cfa_offset 6
 774               		.cfi_offset 15, -5
 775 0008 0F93      		push r16
 776               	.LCFI41:
 777               		.cfi_def_cfa_offset 7
 778               		.cfi_offset 16, -6
 779 000a 1F93      		push r17
 780               	.LCFI42:
 781               		.cfi_def_cfa_offset 8
 782               		.cfi_offset 17, -7
 783 000c CF93      		push r28
 784               	.LCFI43:
 785               		.cfi_def_cfa_offset 9
 786               		.cfi_offset 28, -8
 787 000e DF93      		push r29
 788               	.LCFI44:
 789               		.cfi_def_cfa_offset 10
 790               		.cfi_offset 29, -9
 791               	/* prologue: function */
 792               	/* frame size = 0 */
 793               	/* stack size = 8 */
 794               	.L__stack_usage = 8
 795 0010 C62F      		mov r28,r22
 796 0012 6A01      		movw r12,r20
 797 0014 7901      		movw r14,r18
 155:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   i2c_status_t status = i2c_start(devaddr | 0x00, timeout);
 798               		.loc 1 155 0
 799 0016 B801      		movw r22,r16
 800               	.LVL77:
 801 0018 0E94 0000 		call i2c_start
 802               	.LVL78:
 156:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 803               		.loc 1 156 0
 804 001c 0097      		sbiw r24,0
 805 001e 01F4      		brne .L75
 158:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_write(regaddr, timeout);
 806               		.loc 1 158 0
 807 0020 B801      		movw r22,r16
 808 0022 8C2F      		mov r24,r28
 809               	.LVL79:
 810 0024 0E94 0000 		call i2c_write
 811               	.LVL80:
 159:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 812               		.loc 1 159 0
 813 0028 0097      		sbiw r24,0
 814 002a 01F4      		brne .L75
 815 002c E601      		movw r28,r12
 816               	.LVL81:
 817 002e EC0C      		add r14,r12
 818 0030 FD1C      		adc r15,r13
 819               	.LVL82:
 820               	.L76:
 821               	.LBB4:
 161:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   for (uint16_t i = 0; i < length; i++) {
 822               		.loc 1 161 0 discriminator 1
 823 0032 CE15      		cp r28,r14
 824 0034 DF05      		cpc r29,r15
 825 0036 01F0      		breq .L81
 162:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     status = i2c_write(data[i], timeout);
 826               		.loc 1 162 0
 827 0038 B801      		movw r22,r16
 828 003a 8991      		ld r24,Y+
 829               	.LVL83:
 830 003c 0E94 0000 		call i2c_write
 831               	.LVL84:
 163:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if (status) return status;
 832               		.loc 1 163 0
 833 0040 0097      		sbiw r24,0
 834 0042 01F0      		breq .L76
 835 0044 00C0      		rjmp .L75
 836               	.LVL85:
 837               	.L81:
 838               	.LBE4:
 166:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 839               		.loc 1 166 0
 840 0046 C801      		movw r24,r16
 841               	.LVL86:
 842               	/* epilogue start */
 170:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 843               		.loc 1 170 0
 844 0048 DF91      		pop r29
 845 004a CF91      		pop r28
 846               	.LVL87:
 847 004c 1F91      		pop r17
 848 004e 0F91      		pop r16
 849               	.LVL88:
 850 0050 FF90      		pop r15
 851 0052 EF90      		pop r14
 852 0054 DF90      		pop r13
 853 0056 CF90      		pop r12
 854               	.LVL89:
 166:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 855               		.loc 1 166 0
 856 0058 0C94 0000 		jmp i2c_stop
 857               	.LVL90:
 858               	.L75:
 859               	/* epilogue start */
 170:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 860               		.loc 1 170 0
 861 005c DF91      		pop r29
 862 005e CF91      		pop r28
 863 0060 1F91      		pop r17
 864 0062 0F91      		pop r16
 865               	.LVL91:
 866 0064 FF90      		pop r15
 867 0066 EF90      		pop r14
 868 0068 DF90      		pop r13
 869 006a CF90      		pop r12
 870               	.LVL92:
 871 006c 0895      		ret
 872               		.cfi_endproc
 873               	.LFE7:
 875               		.section	.text.i2c_readReg,"ax",@progbits
 876               	.global	i2c_readReg
 878               	i2c_readReg:
 879               	.LFB8:
 173:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** {
 880               		.loc 1 173 0
 881               		.cfi_startproc
 882               	.LVL93:
 883 0000 CF92      		push r12
 884               	.LCFI45:
 885               		.cfi_def_cfa_offset 3
 886               		.cfi_offset 12, -2
 887 0002 DF92      		push r13
 888               	.LCFI46:
 889               		.cfi_def_cfa_offset 4
 890               		.cfi_offset 13, -3
 891 0004 EF92      		push r14
 892               	.LCFI47:
 893               		.cfi_def_cfa_offset 5
 894               		.cfi_offset 14, -4
 895 0006 FF92      		push r15
 896               	.LCFI48:
 897               		.cfi_def_cfa_offset 6
 898               		.cfi_offset 15, -5
 899 0008 0F93      		push r16
 900               	.LCFI49:
 901               		.cfi_def_cfa_offset 7
 902               		.cfi_offset 16, -6
 903 000a 1F93      		push r17
 904               	.LCFI50:
 905               		.cfi_def_cfa_offset 8
 906               		.cfi_offset 17, -7
 907 000c CF93      		push r28
 908               	.LCFI51:
 909               		.cfi_def_cfa_offset 9
 910               		.cfi_offset 28, -8
 911 000e DF93      		push r29
 912               	.LCFI52:
 913               		.cfi_def_cfa_offset 10
 914               		.cfi_offset 29, -9
 915               	/* prologue: function */
 916               	/* frame size = 0 */
 917               	/* stack size = 8 */
 918               	.L__stack_usage = 8
 919 0010 F82E      		mov r15,r24
 920 0012 E62E      		mov r14,r22
 921 0014 EA01      		movw r28,r20
 922 0016 6901      		movw r12,r18
 174:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   i2c_status_t status = i2c_start(devaddr, timeout);
 923               		.loc 1 174 0
 924 0018 B801      		movw r22,r16
 925               	.LVL94:
 926 001a 0E94 0000 		call i2c_start
 927               	.LVL95:
 928 001e 9C01      		movw r18,r24
 929               	.LVL96:
 175:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 930               		.loc 1 175 0
 931 0020 0097      		sbiw r24,0
 932 0022 01F4      		brne .L87
 177:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_write(regaddr, timeout);
 933               		.loc 1 177 0
 934 0024 B801      		movw r22,r16
 935 0026 8E2D      		mov r24,r14
 936 0028 0E94 0000 		call i2c_write
 937               	.LVL97:
 938 002c 9C01      		movw r18,r24
 939               	.LVL98:
 178:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 940               		.loc 1 178 0
 941 002e 0097      		sbiw r24,0
 942 0030 01F4      		brne .L87
 180:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_start(devaddr | 0x01, timeout);
 943               		.loc 1 180 0
 944 0032 B801      		movw r22,r16
 945 0034 8F2D      		mov r24,r15
 946 0036 8160      		ori r24,lo8(1)
 947 0038 0E94 0000 		call i2c_start
 948               	.LVL99:
 181:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status) return status;
 949               		.loc 1 181 0
 950 003c 0097      		sbiw r24,0
 951 003e 01F4      		brne .L83
 952 0040 7E01      		movw r14,r28
 953               	.LVL100:
 954               	.LBB5:
 183:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   for (uint16_t i = 0; i < (length-1); i++) {
 955               		.loc 1 183 0
 956 0042 81E0      		ldi r24,1
 957 0044 C81A      		sub r12,r24
 958 0046 D108      		sbc r13,__zero_reg__
 959               	.LVL101:
 960               	.L84:
 961 0048 C701      		movw r24,r14
 962 004a 8C1B      		sub r24,r28
 963 004c 9D0B      		sbc r25,r29
 964               	.LVL102:
 183:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   for (uint16_t i = 0; i < (length-1); i++) {
 965               		.loc 1 183 0 is_stmt 0 discriminator 1
 966 004e 8C15      		cp r24,r12
 967 0050 9D05      		cpc r25,r13
 968 0052 00F4      		brsh .L91
 184:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     status = i2c_read_ack(timeout);
 969               		.loc 1 184 0 is_stmt 1
 970 0054 C801      		movw r24,r16
 971               	.LVL103:
 972 0056 0E94 0000 		call i2c_read_ack
 973               	.LVL104:
 185:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     if (status >= 0) {
 974               		.loc 1 185 0
 975 005a 97FD      		sbrc r25,7
 976 005c 00C0      		rjmp .L83
 186:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****       data[i] = status;
 977               		.loc 1 186 0
 978 005e F701      		movw r30,r14
 979 0060 8193      		st Z+,r24
 980 0062 7F01      		movw r14,r30
 981               	.LVL105:
 982 0064 00C0      		rjmp .L84
 983               	.LVL106:
 984               	.L91:
 985               	.LBE5:
 192:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_read_nack(timeout);
 986               		.loc 1 192 0
 987 0066 C801      		movw r24,r16
 988               	.LVL107:
 989 0068 0E94 0000 		call i2c_read_nack
 990               	.LVL108:
 193:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   if (status >= 0 ) {
 991               		.loc 1 193 0
 992 006c 97FD      		sbrc r25,7
 993 006e 00C0      		rjmp .L83
 194:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****     data[(length-1)] = status;
 994               		.loc 1 194 0
 995 0070 CC0D      		add r28,r12
 996 0072 DD1D      		adc r29,r13
 997               	.LVL109:
 998 0074 8883      		st Y,r24
 199:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 999               		.loc 1 199 0
 1000 0076 C801      		movw r24,r16
 1001               	.LVL110:
 1002               	/* epilogue start */
 203:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 1003               		.loc 1 203 0
 1004 0078 DF91      		pop r29
 1005 007a CF91      		pop r28
 1006 007c 1F91      		pop r17
 1007 007e 0F91      		pop r16
 1008               	.LVL111:
 1009 0080 FF90      		pop r15
 1010               	.LVL112:
 1011 0082 EF90      		pop r14
 1012               	.LVL113:
 1013 0084 DF90      		pop r13
 1014 0086 CF90      		pop r12
 1015               	.LVL114:
 199:keyboards/dc01/left/../../../drivers/avr/i2c_master.c ****   status = i2c_stop(timeout);
 1016               		.loc 1 199 0
 1017 0088 0C94 0000 		jmp i2c_stop
 1018               	.LVL115:
 1019               	.L87:
 1020 008c C901      		movw r24,r18
 1021               	.LVL116:
 1022               	.L83:
 1023               	/* epilogue start */
 203:keyboards/dc01/left/../../../drivers/avr/i2c_master.c **** }
 1024               		.loc 1 203 0
 1025 008e DF91      		pop r29
 1026 0090 CF91      		pop r28
 1027               	.LVL117:
 1028 0092 1F91      		pop r17
 1029 0094 0F91      		pop r16
 1030               	.LVL118:
 1031 0096 FF90      		pop r15
 1032               	.LVL119:
 1033 0098 EF90      		pop r14
 1034 009a DF90      		pop r13
 1035 009c CF90      		pop r12
 1036 009e 0895      		ret
 1037               		.cfi_endproc
 1038               	.LFE8:
 1040               		.text
 1041               	.Letext0:
 1042               		.file 2 "/usr/lib/avr/include/stdint.h"
 1043               		.file 3 "keyboards/dc01/left/../../../drivers/avr/i2c_master.h"
 1044               		.file 4 "tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 i2c_master.c
     /tmp/ccXTjhXL.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccXTjhXL.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccXTjhXL.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccXTjhXL.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccXTjhXL.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccXTjhXL.s:13     .text.i2c_init:0000000000000000 i2c_init
     /tmp/ccXTjhXL.s:34     .text.i2c_start:0000000000000000 i2c_start
     /tmp/ccXTjhXL.s:179    .text.i2c_write:0000000000000000 i2c_write
     /tmp/ccXTjhXL.s:269    .text.i2c_read_ack:0000000000000000 i2c_read_ack
     /tmp/ccXTjhXL.s:346    .text.i2c_read_nack:0000000000000000 i2c_read_nack
     /tmp/ccXTjhXL.s:423    .text.i2c_stop:0000000000000000 i2c_stop
     /tmp/ccXTjhXL.s:500    .text.i2c_transmit:0000000000000000 i2c_transmit
     /tmp/ccXTjhXL.s:614    .text.i2c_receive:0000000000000000 i2c_receive
     /tmp/ccXTjhXL.s:754    .text.i2c_writeReg:0000000000000000 i2c_writeReg
     /tmp/ccXTjhXL.s:878    .text.i2c_readReg:0000000000000000 i2c_readReg

UNDEFINED SYMBOLS
timer_read
